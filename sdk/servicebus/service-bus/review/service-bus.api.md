## API Report File for "@azure/service-bus"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AmqpMessage } from '@azure/core-amqp';
import { DataTransformer } from '@azure/core-amqp';
import { delay } from '@azure/core-amqp';
import { Delivery } from 'rhea-promise';
import Long from 'long';
import { MessagingError } from '@azure/core-amqp';
import { TokenCredential } from '@azure/core-amqp';
import { TokenType } from '@azure/core-amqp';
import { WebSocketImpl } from 'rhea-promise';

// @public
export interface CorrelationFilter {
    contentType?: string;
    correlationId?: string;
    label?: string;
    messageId?: string;
    replyTo?: string;
    replyToSessionId?: string;
    sessionId?: string;
    to?: string;
    userProperties?: any;
}

export { DataTransformer }

// @public
export interface DeadLetterOptions {
    deadLetterErrorDescription: string;
    deadletterReason: string;
}

export { delay }

export { Delivery }

// @public
export interface MessageHandlerOptions {
    autoComplete?: boolean;
    maxConcurrentCalls?: number;
    maxMessageAutoRenewLockDurationInSeconds?: number;
}

export { MessagingError }

// @public
export interface OnError {
    (error: MessagingError | Error): void;
}

// @public
export interface OnMessage {
    (message: ServiceBusMessage): Promise<void>;
}

// Warning: (ae-forgotten-export) The symbol "Client" needs to be exported by the entry point index.d.ts
// 
// @public
export class QueueClient implements Client {
    close(): Promise<void>;
    createReceiver(receiveMode: ReceiveMode): Receiver;
    createReceiver(receiveMode: ReceiveMode, sessionOptions: SessionReceiverOptions): SessionReceiver;
    createSender(): Sender;
    readonly entityPath: string;
    static getDeadLetterQueuePath(queueName: string): string;
    readonly id: string;
    peek(maxMessageCount?: number): Promise<ReceivedMessageInfo[]>;
    peekBySequenceNumber(fromSequenceNumber: Long, maxMessageCount?: number): Promise<ReceivedMessageInfo[]>;
}

// @public
export interface ReceivedMessageInfo extends SendableMessageInfo {
    readonly _amqpMessage: AmqpMessage;
    readonly deadLetterSource?: string;
    readonly deliveryCount?: number;
    readonly enqueuedSequenceNumber?: number;
    readonly enqueuedTimeUtc?: Date;
    readonly expiresAtUtc?: Date;
    lockedUntilUtc?: Date;
    readonly lockToken?: string;
    readonly sequenceNumber?: Long;
}

// @public
export enum ReceiveMode {
    peekLock = 1,
    receiveAndDelete = 2
}

// @public
export class Receiver {
    close(): Promise<void>;
    getMessageIterator(): AsyncIterableIterator<ServiceBusMessage>;
    readonly isClosed: boolean;
    isReceivingMessages(): boolean;
    receiveDeferredMessage(sequenceNumber: Long): Promise<ServiceBusMessage | undefined>;
    receiveDeferredMessages(sequenceNumbers: Long[]): Promise<ServiceBusMessage[]>;
    receiveMessages(maxMessageCount: number, idleTimeoutInSeconds?: number): Promise<ServiceBusMessage[]>;
    readonly receiveMode: ReceiveMode;
    registerMessageHandler(onMessage: OnMessage, onError: OnError, options?: MessageHandlerOptions): void;
    renewMessageLock(lockTokenOrMessage: string | ServiceBusMessage): Promise<Date>;
    }

// @public
export interface RuleDescription {
    action?: string;
    filter?: string | CorrelationFilter;
    name: string;
}

// @public
export interface SendableMessageInfo {
    body: any;
    contentType?: string;
    correlationId?: string | number | Buffer;
    label?: string;
    messageId?: string | number | Buffer;
    partitionKey?: string;
    replyTo?: string;
    replyToSessionId?: string;
    scheduledEnqueueTimeUtc?: Date;
    sessionId?: string;
    timeToLive?: number;
    to?: string;
    userProperties?: {
        [key: string]: any;
    };
    viaPartitionKey?: string;
}

// @public
export class Sender {
    cancelScheduledMessage(sequenceNumber: Long): Promise<void>;
    cancelScheduledMessages(sequenceNumbers: Long[]): Promise<void>;
    close(): Promise<void>;
    readonly isClosed: boolean;
    scheduleMessage(scheduledEnqueueTimeUtc: Date, message: SendableMessageInfo): Promise<Long>;
    scheduleMessages(scheduledEnqueueTimeUtc: Date, messages: SendableMessageInfo[]): Promise<Long[]>;
    send(message: SendableMessageInfo): Promise<void>;
    sendBatch(messages: SendableMessageInfo[]): Promise<void>;
    }

// @public
export class ServiceBusClient {
    close(): Promise<any>;
    static createFromConnectionString(connectionString: string, options?: ServiceBusClientOptions): ServiceBusClient;
    createQueueClient(queueName: string): QueueClient;
    createSubscriptionClient(topicName: string, subscriptionName: string): SubscriptionClient;
    createTopicClient(topicName: string): TopicClient;
    readonly name: string;
}

// @public
export interface ServiceBusClientOptions {
    dataTransformer?: DataTransformer;
    webSocket?: WebSocketImpl;
    webSocketConstructorOptions?: any;
}

// Warning: (ae-forgotten-export) The symbol "ReceivedMessage" needs to be exported by the entry point index.d.ts
// 
// @public
export class ServiceBusMessage implements ReceivedMessage {
    abandon(propertiesToModify?: {
        [key: string]: any;
    }): Promise<void>;
    readonly _amqpMessage: AmqpMessage;
    body: any;
    clone(): SendableMessageInfo;
    complete(): Promise<void>;
    contentType?: string;
    correlationId?: string | number | Buffer;
    deadLetter(options?: DeadLetterOptions): Promise<void>;
    readonly deadLetterSource?: string;
    defer(propertiesToModify?: {
        [key: string]: any;
    }): Promise<void>;
    readonly delivery: Delivery;
    readonly deliveryCount?: number;
    readonly enqueuedSequenceNumber?: number;
    readonly enqueuedTimeUtc?: Date;
    readonly expiresAtUtc?: Date;
    readonly isSettled: boolean;
    label?: string;
    lockedUntilUtc?: Date;
    readonly lockToken?: string;
    messageId?: string | number | Buffer;
    partitionKey?: string;
    replyTo?: string;
    replyToSessionId?: string;
    scheduledEnqueueTimeUtc?: Date;
    readonly sequenceNumber?: Long;
    sessionId?: string;
    timeToLive?: number;
    to?: string;
    userProperties?: {
        [key: string]: any;
    };
    viaPartitionKey?: string;
}

// @public
export interface SessionMessageHandlerOptions {
    autoComplete?: boolean;
    maxConcurrentCalls?: number;
}

// @public
export class SessionReceiver {
    close(): Promise<void>;
    getMessageIterator(maxWaitTimeInSeconds?: number): AsyncIterableIterator<ServiceBusMessage>;
    getState(): Promise<any>;
    readonly isClosed: boolean;
    isReceivingMessages(): boolean;
    peek(maxMessageCount?: number): Promise<ReceivedMessageInfo[]>;
    peekBySequenceNumber(fromSequenceNumber: Long, maxMessageCount?: number): Promise<ReceivedMessageInfo[]>;
    receiveDeferredMessage(sequenceNumber: Long): Promise<ServiceBusMessage | undefined>;
    receiveDeferredMessages(sequenceNumbers: Long[]): Promise<ServiceBusMessage[]>;
    receiveMessages(maxMessageCount: number, maxWaitTimeInSeconds?: number): Promise<ServiceBusMessage[]>;
    readonly receiveMode: ReceiveMode;
    registerMessageHandler(onMessage: OnMessage, onError: OnError, options?: SessionMessageHandlerOptions): void;
    renewSessionLock(): Promise<Date>;
    readonly sessionId: string | undefined;
    readonly sessionLockedUntilUtc: Date | undefined;
    setState(state: any): Promise<void>;
    }

// @public
export interface SessionReceiverOptions {
    maxSessionAutoRenewLockDurationInSeconds?: number;
    sessionId: string | undefined;
}

// @public
export class SubscriptionClient implements Client {
    addRule(ruleName: string, filter: boolean | string | CorrelationFilter, sqlRuleActionExpression?: string): Promise<void>;
    close(): Promise<void>;
    createReceiver(receiveMode: ReceiveMode): Receiver;
    createReceiver(receiveMode: ReceiveMode, sessionOptions: SessionReceiverOptions): SessionReceiver;
    readonly defaultRuleName: string;
    readonly entityPath: string;
    getRules(): Promise<RuleDescription[]>;
    readonly id: string;
    peek(maxMessageCount?: number): Promise<ReceivedMessageInfo[]>;
    peekBySequenceNumber(fromSequenceNumber: Long, maxMessageCount?: number): Promise<ReceivedMessageInfo[]>;
    removeRule(ruleName: string): Promise<void>;
    readonly subscriptionName: string;
    readonly topicName: string;
}

export { TokenCredential }

export { TokenType }

// @public
export class TopicClient implements Client {
    close(): Promise<void>;
    createSender(): Sender;
    readonly entityPath: string;
    static getDeadLetterTopicPath(topicName: string, subscriptionName: string): string;
    readonly id: string;
}

// @public (undocumented)
export interface Track2CloseableAsyncIterator<MessageT> extends AsyncIterableIterator<MessageT> {
    // (undocumented)
    close(): Promise<void>;
}

// @public (undocumented)
export interface Track2CloseableThing {
    // (undocumented)
    close(): Promise<void>;
}

// @public (undocumented)
export interface Track2FetchOptions {
    // (undocumented)
    maxWaitTimeInSeconds?: number;
}

// @public (undocumented)
export interface Track2FetchResult<MessageT, ContextT> extends Track2CloseableThing {
    // (undocumented)
    context: ContextT;
    // (undocumented)
    iterator: AsyncIterableIterator<MessageT>;
}

// @public (undocumented)
export interface Track2Message extends Omit<ServiceBusMessage, "abandon" | "complete" | "defer" | "deadLetter"> {
}

// @public (undocumented)
export interface Track2MessageBatch {
    // (undocumented)
    tryAdd(message: Track2Message): boolean;
}

// @public (undocumented)
export interface Track2PeekedMessage extends ReceivedMessageInfo {
}

// @public (undocumented)
export interface Track2PlainContext {
}

// @public (undocumented)
export class Track2QueueConsumerClient {
    constructor(connectionString: string, queueName: string, options?: Track2QueueConsumerClientOptions);
    // (undocumented)
    close(): Promise<void>;
    // (undocumented)
    consume(sessionId: string, mode: "PeekLock", handlers: Track2ReceiverHandlers<Track2SessionMessage, Track2SessionContext & Track2SettleableContext>): Track2CloseableThing;
    // (undocumented)
    consume(sessionId: string, mode: "ReceiveAndDelete", handlers: Track2ReceiverHandlers<Track2SessionMessage, Track2SessionContext>): Track2CloseableThing;
    // (undocumented)
    consume(mode: "PeekLock", handlers: Track2ReceiverHandlers<Track2Message, Track2SettleableContext>): Track2CloseableThing;
    // (undocumented)
    consume(mode: "ReceiveAndDelete", handlers: Track2ReceiverHandlers<Track2Message, Track2PlainContext>): Track2CloseableThing;
    // (undocumented)
    fetch(sessionId: string, mode: "PeekLock", options?: Track2FetchOptions): Track2FetchResult<Track2Message, Track2SettleableContext>;
    // (undocumented)
    fetch(sessionId: string, mode: "ReceiveAndDelete", options?: Track2FetchOptions): Track2FetchResult<Track2Message, Track2PlainContext>;
    // (undocumented)
    fetch(mode: "PeekLock", options?: Track2FetchOptions): Track2FetchResult<Track2Message, Track2SettleableContext>;
    // (undocumented)
    fetch(mode: "ReceiveAndDelete", options?: Track2FetchOptions): Track2FetchResult<Track2Message, Track2PlainContext>;
    // (undocumented)
    peekWithoutLock(sessionId: string, messageCount?: number): Promise<Track2PeekedMessage[]>;
    // Warning: (ae-forgotten-export) The symbol "Long" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    peekWithoutLock(sessionId: string, fromSequenceNumber: Long_2, maxMessageCount?: number): Promise<Track2PeekedMessage[]>;
    // (undocumented)
    peekWithoutLock(messageCount?: number): Promise<Track2PeekedMessage[]>;
    // (undocumented)
    peekWithoutLock(fromSequenceNumber: Long_2, maxMessageCount?: number): Promise<Track2PeekedMessage[]>;
    }

// @public (undocumented)
export interface Track2QueueConsumerClientOptions extends ServiceBusClientOptions {
}

// @public (undocumented)
export class Track2QueueProducerClient {
    constructor(connectionString: string, queueName: string, options?: ServiceBusClientOptions);
    // (undocumented)
    cancelScheduledMessage(sequenceNumber: Long_2): Promise<void>;
    // (undocumented)
    close(): Promise<void>;
    // (undocumented)
    schedule(scheduledEnqueueTimeUtc: Date, message: Track2SendableMessage): Promise<Long_2>;
    // (undocumented)
    send(message: Track2SendableMessage): Promise<void>;
    }

// @public (undocumented)
export interface Track2ReceiverHandlers<MessageType, ContextType> {
    // (undocumented)
    processError(err: Error, context: Track2PlainContext): Promise<void>;
    // (undocumented)
    processEvents(messages: MessageType[], context: ContextType): Promise<void>;
}

// @public (undocumented)
export interface Track2SendableMessage extends SendableMessageInfo {
}

// @public (undocumented)
export interface Track2SessionContext {
    // (undocumented)
    renewSessionLock(): Promise<void>;
    // (undocumented)
    sessionId: string;
}

// @public (undocumented)
export interface Track2SessionMessage extends Track2Message {
    // (undocumented)
    sessionId: string;
}

// @public (undocumented)
export interface Track2SettleableContext {
    // (undocumented)
    abandon(message: Track2Message): Promise<void>;
    // (undocumented)
    complete(message: Track2Message): Promise<void>;
    // (undocumented)
    deadLetter(message: Track2Message): Promise<void>;
    // (undocumented)
    defer(message: Track2Message): Promise<void>;
}

export { WebSocketImpl }


// (No @packageDocumentation comment for this package)

```
